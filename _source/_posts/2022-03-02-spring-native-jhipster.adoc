---
#keywords: spring native
layout: blog_post
title: "Spring Native: start your JHipster + Spring Boot app in just 1sÔ∏è!"
#title: "Spring Native: starting your Java apps in seconds!"
#title: "Introducing JHipster Native: serverless full-stack Java for all ‚ö°Ô∏è"
#title: "Spring Boot + Spring Native + { Angular, React, Vue } = JHipster! üöÄ"
#title: "Start your Spring Boot app in 1 seconds like I did, a HowTo Guide"
#title: "Introducing JHipster Native: 'Wow! That was quick!' üòÇ"
#title: "Native Java with Spring Boot, Spring Native, and JHipster"
author: matt-raible
by: advocate
communities: [java]
description: "Do you want to build a full-stack Java webapp that starts in milliseconds? Spring has your back! üëä"
tags: [java, spring-boot, spring-native, jhipster, graalvm]
tweets:
- "Start your @JHipster + Spring Boot app in just over 1s with @GraalVM!"
- "Introducing JHipster Native: 'Wow! That was quick!' üòÇ"
- "Oh my... that was fast! Is your name @springboot?"
image:
type: conversion
# keywords: spring native (6600), native java (2400, but different topic), spring native jhipster (70)
# My LinkedIn post is at the bottom of Google's page 1! That's the one to beat.
# https://www.linkedin.com/pulse/jhipster-works-spring-native-matt-raible/
github: https://github.com/oktadev/auth0-full-stack-java-example/tree/spring-native
---
:page-liquid:
:toc: macro
:experimental:
:commandkey: &#8984;

Over the years, I've developed a lot of Java applications. I started writing Java code in the late 90s and spent several years doing Java before I tried another server-side language. I was impressed when I first tried building apps in Ruby on Rails, Python, and Node.js - they all started super-fast!

Starting fast is cool, but we in the Java community have often asked, does it perform over time? The Java Virtual Machine is famous for performance and optimization over time.

I scoffed at serverless when it first came out. Mostly because I was a Java developer and my apps didn't start in milliseconds. They also used a whole lotta memory and there was no hope in sight.

Then, along came https://www.graalvm.org/[GraalVM]. It's gained support from many Java frameworks in the last few years and has made their apps start in milliseconds!

Today, I'm proud to announce that this same capability is now available for your JHipster 7+ apps!

////
*Prerequisites*:

- https://sdkman.io/[Java 17 with GraalVM]+
- https://docs.docker.com/desktop/#download-and-install[Docker Desktop]
////

toc::[]

== Why should you care about serverless?

From https://www.ibm.com/cloud/learn/serverless[IBM's What is Serverless computing?]

> Serverless is a cloud execution model that enables a simpler, more cost-effective way to build and operate cloud-native applications.

That's it!

For companies with high traffic and large cloud bills, serverless makes sense. They can save millions of dollars a month.

== GraalVM allows serverless Java for everyone!

I've been playing with GraalVM and the Java frameworks that support it for around 18 months. After doing a lot of research, I blogged about link:/blog/2021/06/18/native-java-framework-comparison[building native Java apps with Micronaut, Quarkus, and Spring Boot].

In September 2021, I did a talk with Josh Long about Spring Native with JHipster at the San Francisco JUG.

++++
{% twitter 1442698739563446276 %}
++++

I flew out on a Monday, we got everything working by Wednesday afternoon, and then spoke about our experience on Wednesday night. I wrote about it in https://www.linkedin.com/pulse/jhipster-works-spring-native-matt-raible/[JHipster Works with Spring Native!] on LinkedIn and created a https://github.com/jhipster/generator-jhipster/issues/16498[JHipster issue] to automate our learnings.

== What is Spring Native?

Spring Native provides an API to configure Spring Boot and GraalVM so classes that are not easily discoverable become recognizable. For example, those that are instantiated using reflection. It's a really slick extension to Spring Boot and will likely disappear with Spring Boot 3 because it'll be native by default.

As a result of our successful https://youtu.be/F9oydL_MndA[presentation at the SF JUG], Josh and I were invited to speak at the Garden State JUG in December. We laid low for a few months and rekindled our research in December. I wrote about it in https://www.linkedin.com/pulse/jhipster-works-spring-native-part-2-matt-raible/[JHipster works with Spring Native, Part 2!]

== üî• Announcing the JHipster Native blueprint v1.0!

In late January 2022, we (the JHipster team) upgraded JHipster to use Spring Boot 2.6 and released version https://www.jhipster.tech/2022/01/23/jhipster-release-7.6.0.html[7.6.0].

In early February, I updated the Spring Native with JHipster examples that Josh and I'd been using for research. I was ready to start automating the Spring Native integration using a JHipster module. When https://github.com/jhipster/generator-jhipster/issues/16498#issuecomment-1030263905[I asked the JHipster team] about the best way to implement it, https://github.com/mshima[Marcelo Shima] volunteered to create the initial blueprint.

This was on a Friday afternoon (Mountain Time or MT). By the next morning, Marcelo had the MVP finished and provided steps to reproduce our examples. üò≥

I was amazed! I remember telling (my partner) Trish that he'd done a week's worth of (my estimated) work in a matter of hours.

Today, I'm proud to announce the https://github.com/jhipster/generator-jhipster-native[JHipster Native blueprint] is available! Here's how to use it:

[source,shell]
----
npm install -g generator-jhipster-native
jhipster-native
----

This will generate a JHipster app and integrate GraalVM automatically. You can build and run a native image with the following commands:

[source,shell]
----
./mvnw package -Pnative,prod -DskipTests
./target/native-executable
----

NOTE: Gradle is not currently an option, but it can be if we add support to the JHipster Native blueprint.

== Go native with Spring Native and GraalVM

To see Spring Native + JHipster in action, let's look at a https://auth0.com/blog/full-stack-java-with-react-spring-boot-and-jhipster/[previous JHipster app I created for the Auth0 blog]. First, clone the example:

[source,shell]
----
git clone https://github.com/oktadev/auth0-full-stack-java-example.git jhipster-native
cd jhipster-native
----

[TIP]
====
Want results right away? Clone the `spring-native` branch with the changes below already made:
----
git clone -b spring-native https://github.com/oktadev/auth0-full-stack-java-example.git jhipster-native
----

Then, skip to the <<Configure your OpenID Connect identity provider>> section to continue.
====

Install JHipster 7.7.0 and the JHipster Native blueprint:

[source,shell]
----
npm i -g generator-jhipster@7.7
npm i -g generator-jhipster-native@1.0
----

Then, remove all the existing project files and regenerate it.

[source,shell]
----
rm -rf *
jhipster-native --with-entities
# When prompted to overwrite .gitignore, type "a" to overwrite all files
----

If you open the project in IntelliJ IDEA, you can use the *Commit Tools Window* (kbd:[{commandkey} + 0] on macOS or kbd:[Ctrl + 0] on Linux/Windows) to view files that changed.

image::{% asset_path 'blog/spring-native-jhipster/commit-tools-window.jpg' %}[alt=IntelliJ IDEA's Commit Tools Window,align=center]

Next, run the following `git checkout` commands to restore the files that were modified in the original example.

[source,shell]
----
git checkout .gitignore
git checkout README.md
git checkout demo.adoc
git checkout flickr2.jdl
git checkout screenshots
git checkout src/test/javascript/cypress/integration/entity/photo.spec.ts
git checkout src/main/webapp/app/entities/photo/photo.tsx
git checkout src/main/webapp/app/entities/photo/photo-update.tsx
git checkout src/main/java/com/auth0/flickr2/config/SecurityConfiguration.java
git checkout src/main/java/com/auth0/flickr2/web/rest/PhotoResource.java
git checkout src/main/resources/config/application-heroku.yml
git checkout src/main/resources/config/bootstrap-heroku.yml
git checkout Procfile
git checkout system.properties
----

If you'd rather not use the command line, you can right-click on each file and select *Rollback*.

image::{% asset_path 'blog/spring-native-jhipster/rollback-commit.png' %}[alt=Rollback...,align=center]

If you ran the `git checkout` commands, there are a few other changes I made in the first tutorial that'll need to be re-applied:

. In `src/main/resources/config/application-dev.yml`, remove the `faker` profile for Liquibase.

. In `pom.xml`, re-add Drew Noake's `metadata-extractor` library:
+
[source,xml]
----
<dependency>
    <groupId>com.drewnoakes</groupId>
    <artifactId>metadata-extractor</artifactId>
    <version>2.16.0</version>
</dependency>
----

. Install the React libraries needed:
+
[source,shell]
----
npm i react-photo-gallery@8 --force
npm i react-images
----

Then, you'll need to add type hints for Drew Noake's EXIF processing library in your main application class:

[source,java]
----
@org.springframework.nativex.hint.TypeHint(
types = {
    ...
    com.drew.metadata.exif.ExifIFD0Directory.class,
    com.drew.metadata.exif.ExifSubIFDDirectory.class,
    com.drew.metadata.exif.makernotes.AppleMakernoteDirectory.class,
    com.drew.metadata.exif.GpsDirectory.class,
})
@org.springframework.nativex.hint.NativeHint(options = "-H:+AddAllCharsets")
----

The `@NativeHint(options = "-H:+AddAllCharsets")` solves the following exception that happens when you upload a photo:

----
Caused by: java.nio.charset.UnsupportedCharsetException: Cp1252
at java.nio.charset.Charset.forName(Charset.java:528) ~[native-executable:na]
at com.drew.lang.Charsets.<clinit>(Charsets.java:40) ~[native-executable:2.16.0]
----

Once you've made all the changes (or cloned the `spring-native` branch), you can build your hip native binary.

=== Build a native JHipster app

You will need a JDK with GraalVM and its `native-image` compiler. Using SDKMAN, run the following command and set it as the default:

[source,shell]
----
sdk install java 21.3.0.r17-grl
----

Add the native extension to the JDK:

[source,shell]
----
gu install native-image
----

Then, use Maven to build the project. Skip tests since there's no support for Mockito at this time.

[source,shell]
----
./mvnw package -Pnative,prod -DskipTests
----

This process will take several minutes to complete.

=== Configure your OpenID Connect identity provider

When you generate a JHipster app with OAuth 2.0 / OIDC for authentication, it defaults to using Keycloak. It creates a `src/main/docker/keycloak.yml` file for Docker Compose, as well as a `src/main/docker/realm-config` directory with files to auto-create users and OIDC clients.

If you want to use Keycloak for your running app, start it with the following command:

[source,shell]
----
docker-compose -f src/main/docker/keycloak.yml up -d
----

If you'd rather use Okta or Auth0, that's possible too!

==== Use Okta as your identity provider

{% include setup/cli.md type="jhipster" %}

You'll need to source the `.okta.env` file the Okta CLI creates to override the default Spring Security settings.

[source,shell]
----
source .okta.env
----

NOTE: If you're on Windows, you can modify this file to use `set` instead of `export` and rename it to `okta.bat`. Then, run it with `okta.bat` from the command line.

CAUTION: Modify your existing `.gitignore` file to have `*.env` so you don't accidentally check in your secrets!

_Skip to <<Run your native JHipster app>> if you've configured your app for Okta and just want to see it running._

==== Use Auth0 as your identity provider

To switch from Keycloak to Auth0, override the Spring Security OAuth properties. You don't even need to write any code!

To see how it works, create a `.auth0.env` file in the root of your project, and fill it with the code below to override the default OIDC settings:

[source,shell]
----
export SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_OIDC_ISSUER_URI=https://<your-auth0-domain>/
export SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_OIDC_CLIENT_ID=<your-client-id>
export SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_OIDC_CLIENT_SECRET=<your-client-secret>
export JHIPSTER_SECURITY_OAUTH2_AUDIENCE=https://<your-auth0-domain>/api/v2/
----

You'll need to create a new web application in Auth0 and fill in the `<...>` placeholders before this works.

===== Create an OpenID Connect app on Auth0

Log in to your Auth0 account (or https://auth0.com/signup[sign up] if you don't have an account). You should have a unique domain like `dev-xxx.eu.auth0.com`.

Press the **Create Application** button in the https://manage.auth0.com/#/applications[Applications section]. Use a name like `JHipster Native!`, select `Regular Web Applications`, and click **Create**.

Switch to the **Settings** tab and configure your application settings:

- Allowed Callback URLs: `\http://localhost:8080/login/oauth2/code/oidc`
- Allowed Logout URLs: `\http://localhost:8080/`

Scroll to the bottom and click **Save Changes**.

Copy your Auth0 domain, client ID, and client secret into the `.auth0.env` file you created earlier. Then, run `source .auth0.env`.

In the https://manage.auth0.com/#/roles[roles] section, create new roles named `ROLE_ADMIN` and `ROLE_USER`.

Create a new user account in the https://manage.auth0.com/#/users[users] section. Click on the **Role** tab to assign the roles you just created to the new account.

_Make sure your new user's email is verified before attempting to log in!_

Next, head to **Auth Pipeline** > **Rules** > **Create**. Select the `Empty rule` template. Provide a meaningful name like `Group claims` and replace the Script content with the following.

[source,js]
----
function(user, context, callback) {
  user.preferred_username = user.email;
  const roles = (context.authorization || {}).roles;

  function prepareCustomClaimKey(claim) {
    return `https://www.jhipster.tech/${claim}`;
  }

  const rolesClaim = prepareCustomClaimKey('roles');

  if (context.idToken) {
    context.idToken[rolesClaim] = roles;
  }

  if (context.accessToken) {
    context.accessToken[rolesClaim] = roles;
  }

  callback(null, user, context);
}
----

This code is adding the user's roles to a custom claim (prefixed with `\https://www.jhipster.tech/roles`). Click **Save changes** to continue.

TIP: Want to have all these steps automated for you? Add a üëç to https://github.com/auth0/auth0-cli/issues/351[issue #351] in the Auth0 CLI project.

=== Run your native JHipster app

After you've built your app, it will be available in `target/native-executable`. Start Keycloak or source your Okta/Auth0 settings. Then, run `./target/native-executable`. It should start in under one second!

++++
{% twitter 1494118802988089348 %}
++++

// todo: I like showing the tweet ^^ because it got so many likes, but maybe just the screenshot would be better?

== What does the JHipster Native blueprint do?

The JHipster Native plugin integrates Spring Native into a JHipster project based on https://github.com/mraible/spring-native-examples#readme[findings from the research by Josh Long and me]. I documented our findings in September and December 2021.

- Sep 30, 2021: https://www.linkedin.com/pulse/jhipster-works-spring-native-matt-raible/[JHipster Works with Spring Native!]
- Dec 14, 2021: https://www.linkedin.com/pulse/jhipster-works-spring-native-part-2-matt-raible/[JHipster works with Spring Native, Part 2!]

The unexpected thing is, one of the hardest problems we had to solve was with JPA and relationships. In JVM mode, everything worked fine. When running in native mode, https://github.com/jhipster/generator-jhipster/issues/17794[there was an exception]. The solution took days to figure out, but was quite simple to fix: I just had to add a type hint for `java.util.HashSet.class`. ü§Ø

During this experience, I was surprised to find that Spring Native https://github.com/spring-projects-experimental/spring-native/issues/465[doesn't support caching yet]. I believe this support will be added by the community soon. In the meantime, if you're looking to start/stop your infra as fast as possible, you probably don't care about caching. Caching is made for long-lived, JVM-strong, JVM-loving apps.

////
== What about Spring Boot 3?

// an attempt, but no demo: https://www.youtube.com/watch?v=J2_-eC7Mpfk
// if demo ready, schedule!

== Automate the wait

jhipster ci-cd

Options:

- Modify the generated YAML to use the GraalVM plugin
- Revert the script changes in package.json so it's just a JVM build. Add a publish script that only builds when you create a release.
- Nightly build of native https://kyuubang.github.io/devops/2022/01/22/nightly-build-with-github-actions.html

This post is already long enough. I'll show you in a future post!

In the next post, show existing blueprint tests

https://github.com/jhipster/generator-jhipster-native/blob/main/.github/workflows/jdl.yml

////

== What's the performance like?

The native binary starts in just over 1s on my 2019 MacBook Pro with a 2.4 GHz 8-Core Intel Core i9 processor and 64 GB of RAM. If I start it in JVM mode with Maven, it takes https://twitter.com/mraible/status/1494123702203654148[around six seconds].

As far as build time goes, Spring Native says:

----
Finished generating 'native-executable' in 3m 28s.
----

Maven tells a different story:

----
[INFO] Total time:  04:36 min
----

If I build a Docker image with the native binary:

----
mvn spring-boot:build-image -Pprod
----

It takes a while the first time:

----
Total time:  09:25 min
----

And it's a little faster the 2nd time:

----
Total time:  07:52 min
----

The amount of memory used after starting: `179 MB`.

The amount of memory used after running `npm run e2e`: `247 MB`.

In the interest of full disclosure, here's the command I used to measure the amount of memory used:

----
ps -o pid,rss,command | grep --color native | awk '{$2=int($2/1024)" MB";}{ print;}'
----

What about the M1 Max? That's https://twitter.com/mraible/status/1494417051137585152[not an option yet].

== Learn more about GraalVM and Spring Native

I hope you've enjoyed learning how to make JHipster work with Spring Native and GraalVM. It's still a work-in-progress. Startup time isn't the end-all-be-all metric, but it is important in a serverless environment.

You can find the source code for this example on GitHub in the https://github.com/oktadev/auth0-full-stack-java-example/tree/spring-native[auth0-full-stack-java-example repository].

JHipster also has Micronaut and Quarkus blueprints. However, their native support is currently a work-in-progress. I hope to help improve them in the next few months.

- https://github.com/jhipster/generator-jhipster-quarkus/issues/222[JHipster Quarkus can't build native image]
- https://github.com/jhipster/generator-jhipster-micronaut/issues/115[JHipster Micronaut can't build native image]

If you liked this post, there's a good chance you'll like similar ones:

- link:/blog/2019/11/27/graalvm-java-binaries[Watch GraalVM turn your Java into binaries]
- link:/blog/2021/09/16/spring-native-okta-starter[Spring Native in Action with the Okta Spring Boot Starter]
- link:/blog/2021/06/18/native-java-framework-comparison[Build Native Java Apps with Micronaut, Quarkus, and Spring Boot]
- link:/blog/2022/01/06/native-java-helidon[Build REST APIs and Native Java Apps with Helidon]

If you have questions, please ask them in the comments below! If you're into social media, follow us: https://twitter.com/oktadev[@oktadev on Twitter], https://www.linkedin.com/company/oktadev[Okta for Developers on LinkedIn], https://www.facebook.com/oktadevelopers[OktaDev] on Facebook. If you like learning via video, subscribe to https://youtube.com/oktadev[our YouTube channel].
