---
layout: blog_post
title: "Git Yer Java Microservices to the Cloud with K8s and Spring Boot"
# title: "Git to the Cloud with K8s and Spring Boot"
# title: "Git to Google Cloud with K8s and Spring Boot"
author: matt-raible
by: advocate
communities: [devops,java]
description: "Giddyup and go into the cloud!"
tags: []
tweets:
- ""
- ""
- ""
image:
type: conversion
---
:page-liquid:
:toc: macro
:experimental:

When your business or application is successful, it needs to scale. Not just technology-wise, but human-wise. When you're growing rapidly, it can be difficult to hire developers fast enough. Using a microservices architecture for your apps can allow you to divide up ownership, responsibilities, and scale teams with your code.

Spring Boot and Spring Cloud were some of the pioneering frameworks in Javaland. However, even they stood on the shoulders of giants when they leveraged Netflix open source projects to embrace and extend. In 2018, https://netflixtechblog.com/netflix-oss-and-spring-boot-coming-full-circle-4855947713a0[Netflix OSS announced they'd come full circle], and adopted Spring Boot.

Today, I'd like to show you how to build a __reactive__ microservice architecture with Spring Boot, Spring Cloud, and JHipster. Why reactive? Because Spring Cloud Gateway is now the default for JHipster 7, even if you choose to build your microservices with Spring MVC.

Spring Cloud Gateway is a library for building an API Gateway on top of Spring WebFlux. It makes it easy to integrate OAuth in to communicate between microservices. You just need to add a `TokenRelay` filter.

[source,yaml]
----
spring:
  cloud:
    gateway:
      default-filters:
        - TokenRelay
----

CAUTION: Netflix Zuul is no longer supported by Spring Cloud. There is an https://github.com/spring-cloud/spring-cloud-gateway/issues/36[open issue] to add Spring MVC/Servlet support to Spring Cloud Gateway.

**Prerequisites**

- https://sdkman.io/[Java 11]+
- https://nodejs.org/[Node.js]
- https://docs.docker.com/get-docker/[Docker]
- A https://cloud.google.com/[Google Cloud] Account

toc::[]

== A Brief Intro to Kubernetes (K8s)

Kubernetes is an open source project from Google that provides an API for deploying your apps and making them talk with each other. It helps automate deployments, updates, and managing your apps and services with limited downtime. You use Docker containers and YAML to make it all work.

The YAML can be hideous, but that's where JHipster comes in. It can generate the YAML for you!

== Create a Kubernetes-Ready Microservices Architecture

I showed you how to build https://developer.okta.com/blog/2021/01/20/reactive-java-microservices[Reactive Java microservices with Spring Boot and JHipster] in a previous post. Today I'll show you how to generate K8s deployment descriptors, use Spring Cloud Config with Git, encrypt your secrets, and make it all work on Google Cloud (https://cloud.google.com/kubernetes-engine/[GKE] to be specific).

Start by cloning the JHipster 7 { Vue, Spring Boot, WebFlux } app from GitHub:

[source,shell]
----
git clone https://github.com/oktadeveloper/java-microservices-examples.git
cd java-microservices-examples/reactive-jhipster
----

[TIP]
====
If you just want to see the completed project, just cd into the project's `jhipster-k8s` directory.

[source,shell]
----
cd ../jhipster-k8s
----
====

This project has four directories:

- `gateway`: a Spring Boot + Spring Cloud Gateway project configured for OpenID Connect (OIDC) login. It's also configured as an OAuth 2.0 resource server. It contains a front end application that's built with Vue.
- `blog`: a Spring Boot + WebFlux microservice that talks to a Neo4j database.
- `store`: a Spring Boot + WebFlux microservice that uses MongoDB.
- `docker-compose`: a set of Docker files that describe how to run all containers together.

NOTE: The SPA app on the gateway is currently a monolith. The JHipster team is still working on https://github.com/jhipster/generator-jhipster/issues/10189[micro frontends support].

Once you've configured OIDC, you'll use Docker Compose to run everything.

Now that you have the project cloned, use JHipster to add Kubernetes support.

If you don't have JHipster installed, install it.

[source,shell]
----
npm i -g generator-jhipster@7
----

== Create a Container Registry on Google Cloud

Before the JHipster 7.0.0 release, I tested this microservice example with Kubernetes and Google Cloud. Ray Tsang's https://spring-gcp.saturnism.me/[Spring Boot on GCP Guides] where a https://twitter.com/mraible/status/1372964263237718026[huge help]!

// todo: move this somewhere else as it's kinda in the way

++++
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I re-created this example with the latest code from <a href="https://twitter.com/jhipster?ref_src=twsrc%5Etfw">@jhipster</a>&#39;s main branch this week and deployed it to <a href="https://twitter.com/googlecloud?ref_src=twsrc%5Etfw">@googlecloud</a> with <a href="https://twitter.com/kubernetesio?ref_src=twsrc%5Etfw">@kubernetesio</a>. <br><br>I&#39;m happy to report I was able to get everything working! <a href="https://twitter.com/saturnism?ref_src=twsrc%5Etfw">@saturnism</a>&#39;s Spring Boot on GCP docs was a big help. üôè<a href="https://t.co/NBGj0OAOxM">https://t.co/NBGj0OAOxM</a> <a href="https://t.co/k1mm4e1fr8">https://t.co/k1mm4e1fr8</a></p>&mdash; Matt Raible (@mraible) <a href="https://twitter.com/mraible/status/1372964263237718026?ref_src=twsrc%5Etfw">March 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
++++

https://spring-gcp.saturnism.me/getting-started/google-cloud-platform[Sign up for Google Cloud Platform (GCP)], log in, and create a project. Open a https://console.cloud.google.com/[console] in your browser. A GCP project contains all cloud services and resources--such as virtual machines, network, load balancers--that you might use.

TIP: You can also download and install the https://cloud.google.com/sdk/[`gcloud` CLI] if you want to run things locally.

Enable the Google Kubernetes Engine API:

[source,shell]
----
gcloud services enable container.googleapis.com containerregistry.googleapis.com
----

Install `kubectl` CLI:

[source,shell]
----
gcloud components install kubectl
----

Run the following command to create a cluster for your apps.

[[create-cluster]]
[source,shell]
----
gcloud container clusters create CLUSTER_NAME \
--zone us-central1-a \
--machine-type n1-standard-4 \
--enable-autorepair \
--enable-autoupgrade
----

I called mine `reactive-ms`. See GCP's https://cloud.google.com/compute/docs/regions-zones/[zones] and https://cloud.google.com/compute/docs/machine-types/[machine-types] for other options. I found the `n1-standard-4` to be the minimum for JHipster.

== Generate Kubernetes Deployment Descriptors

Navigate to the `reactive-jhipster` directory. Create a `k8s` directory, cd into it, and run JHipster's https://www.jhipster.tech/kubernetes/[Kubernetes sub-generator].

[source,shell]
----
mkdir k8s
jhipster k8s
----

You'll be prompted with a number of questions. Answer them as I did below.

- Type of application: **Microservice application**
- Root directory: **../**
- Which applications? <select all>
- Set up monitoring? **No**
- Which applications with clustered databases? select **store**
- Admin password for JHipster Registry: <generate one>
- Kubernetes namespace: **default**
- Docker repository name: `gcr.io/YOUR_GCP_PROJECT_ID`
- Command to push Docker image: `docker push`
- Enable Istio? **No**
- Kubernetes service type? **LoadBalancer**
- Use dynamic storage provisioning? **Yes**
- Use a specific storage class? <leave empty>

image::{% asset_path 'blog/reactive-java-kubernetes/jhipster-k8s.png' %}[alt=JHipster K8s command with answers,width=800,align=center]

Notice that I'm using `gcr.io/jhipster7` for my Docker repository name.

After I answered these questions, my `k8s/.yo-rc.json` file had the following contents:

[source,json]
----
{
  "generator-jhipster": {
    "appsFolders": ["blog", "gateway", "store"],
    "directoryPath": "../",
    "clusteredDbApps": ["store"],
    "serviceDiscoveryType": "eureka",
    "dockerRepositoryName": "gcr.io/jhipster7",
    "dockerPushCommand": "docker push",
    "kubernetesNamespace": "default",
    "kubernetesServiceType": "LoadBalancer",
    "kubernetesUseDynamicStorage": false,
    "kubernetesStorageClassName": "",
    "ingressDomain": "",
    "monitoring": "no",
    "istio": false
  }
}
----

Create Docker images for each app. In the {`gateway`, `blog`, `store` } directories, run the following Gradle command:

[source,shell]
----
./gradlew -Pprod bootJar jibDockerBuild
----

=== Register an OIDC App for Auth

You've built Docker images for your microservices, but you haven't seen them running. First, you'll need to configure Okta for authentication and authorization.

{% include setup/cli.md type="jhipster" %}

JHipster ships with https://www.jhipster.tech/jhipster-registry/[JHipster Registry]. It acts as a Eureka service for service discovery, and contains a Spring Cloud Config server for distributing your configuration settings.

Update `docker-compose/central-server-config/application.yml` to contain your OIDC settings from the `.okta.env` file the Okta CLI just created. The Spring Cloud Config server reads from this file and shares the values with the gateway and microservices.

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          oidc:
            issuer-uri: https://<your-okta-domain>/oauth2/default
        registration:
          oidc:
            client-id: <client-id>
            client-secret: <client-secret>
----

Then, in the `docker-compose` directory, start your engines!

[source,shell]
----
docker-compose up
----

You can see if everything started up OK at `\http://localhost:8761`. You'll need to sign in with your Okta credentials.

Once all is green, go to `\http://localhost:8080` and you should be able to add blogs, posts, tags, and products.

You can also automate testing that everything works. Set your Okta credentials as environment variables and run end-to-end tests (from the gateway directory).

[source,shell]
----
export CYPRESS_E2E_USERNAME=<your-username>
export CYPRESS_E2E_PASSWORD=<your-password>
npm run e2e
----

Proof it worked for me:

image::{% asset_path 'blog/reactive-java-kubernetes/cypress-e2e.png' %}[alt=Cypress end-to-end tests,width=800,align=center]

=== Why Not Istio?

I didn't use Istio in this example because I didn't want to complicate things. Learning Kubernetes is hard enough without learning another system on top of it. Istio acts as a network between your containers that's able to do networky things like authentication, authorization, monitoring, and retries. I like to think of it as AOP for containers.

I recently listened to The New Stack's Podcast episode, https://thenewstack.io/which-comes-first-istio-or-kubernetes/[Which Comes First: Istio or Kubernetes?]. It talks to https://www.linkedin.com/in/varuntalwar/[Varun Talwar] and https://www.linkedin.com/in/zack-butcher-339a2180[Zack Butcher],
creators of Istio. I like how they'd eventually like to make services meshes so boring that everyone uses them and developers don't have to worry about it.

If you'd like to see how to use JHipster with Istio, see https://dev.to/deepu105/how-to-set-up-java-microservices-with-istio-service-mesh-on-kubernetes-5bkn[How to set up Java microservices with Istio service mesh on Kubernetes] by JHipster co-lead https://twitter.com/deepu105[Deepu K Sasidharan].

=== Plain Text Secrets? Uggh!

You might notice I used a secret in plain text in the `application.yml` file. This is a bad practice! I hope you didn't check everything into source control yet!!

== Encrypt / Decrypt Your Spring Cloud Configuration

The JHipster Registry has an encryption mechanism you can use to encrypt your secrets. That way, it's a bit safer to store them in public repositories. Create a `docker-compose/.env` file and specify an `ENCRYPT_KEY` in it. Make sure `*.env` is in your `.gitignore` file while you're at it!

[source,dotenv]
----
ENCRYPT_KEY=really-long-string-of-random-charters-that-you-can-keep-safe
----

[TIP]
====
You can use JShell to generate a UUID you can use for your encrypt key.

[source,shell]
----
jhsell

UUID.randomUUID()
----

image::{% asset_path 'blog/reactive-java-kubernetes/jshell-uuid.png' %}[alt=JShell UUID,width=780,align=center]

You can quit by typing `/exit`.
====

Then, update `docker-compose.yml` to set this value as an environment variable.

[source,yaml]
----
jhipster-registry:
  ...
  environment:
    - _JAVA_OPTIONS=-Xmx512m -Xms256m
    - JHIPSTER_SLEEP=20
    - SPRING_PROFILES_ACTIVE=dev,oauth2
    - SPRING_SECURITY_USER_PASSWORD=admin
    - JHIPSTER_REGISTRY_PASSWORD=*******
    - ENCRYPT_KEY=${ENCRYPT_KEY}
----

Stop all your containers using kbd:[Ctrl + C] or run `docker-compose down`. Start all your containers again.

[source,shell]
----
docker-compose up
----

=== Encrypt Your OIDC Client Secret

You can encrypt your client secret by logging into `http://localhost:8761` and going to **Configuration** > **Encryption**.

Copy and paste your client secret from `application.yml` (or `gateway/.okta.env`) and click **Encrypt**.

image::{% asset_path 'blog/reactive-java-kubernetes/registry-encrypt.png' %}[alt=JHipster Registry Encrypt Feature,width=800,align=center]

Then, copy the encrypted value back in to `application.yml`. Make sure to wrap it in quotes!

You can also use curl:

[source,shell]
----
curl -X POST http://admin:admin@localhost:8761/config/encrypt -d your-client-secret
----

If you use curl, make sure to add `{cipher}` to the beginning of the string. For example:

[source,yaml]
----
client-secret: "{cipher}1b12934716c32d360c85f651a0793df2777090c..."
----

Restart the JHipster Registry for the new values to take effect.

[source,shell]
----
docker-compose stop jhipster-registry
docker-compose start jhipster-registry
----

Verify everything still works at `http://localhost:8080`.

TIP: If you want to make it so you don't need to restart the Spring Cloud Config server when you `git push`, see https://developer.okta.com/blog/2020/12/07/spring-cloud-config#refresh-the-configuration-in-your-spring-cloud-config-server[Refresh the Configuration in Your Spring Cloud Config Server].

== Change Spring Cloud Config Server to use Git

You might want to store your app's configuration externally. That way, you don't have to redeploy everything to change values. Good news! Spring Cloud Config makes it easy to switch to Git instead of the filesystem to store your configuration.

In `docker-compose.yml`, replace the following variables:

[source,yaml]
----
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_TYPE=native
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_SEARCH_LOCATIONS=file:./central-config
----

With values for a GitHub repo.

[source,yaml]
----
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_TYPE=git
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_URI=https://github.com/mraible/reactive-java-ms-config/
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_SEARCH_PATHS=config
- SPRING_CLOUD_CONFIG_SERVER_COMPOSITE_0_LABEL=main
----

Make sure to change the URI to your repo, or you'll be using my OIDC app!

See Spring Cloud Config's https://cloud.spring.io/spring-cloud-config/multi/multi__spring_cloud_config_server.html#_git_backend[Git Backend docs] for more information.

== Deploy to Google Cloud (aka GCP)

Now it's time to go to the moon! Errr... cloud.

You created Docker images earlier to run with Docker Compose. Those images were deployed to your local Docker registry. For Google Cloud and its Kubernetes engine (GKE), you'll need to publish your images to your project's registry. Thankfully, this is easy to do with Jib.

Navigate to the `gateway` directory and run:

[source,shell]
----
./gradlew bootJar -Pprod jib -Djib.to.image=gcr.io/jhipster7/gateway
----

Repeat the process for `blog` and `store`. You can run these processes in parallel to speed things up. Make sure to change the image name at the end of each command.

[source,shell]
----
cd ../blog
./gradlew bootJar -Pprod jib -Djib.to.image=gcr.io/jhipster7/blog
cd ../store
./gradlew bootJar -Pprod jib -Djib.to.image=gcr.io/jhipster7/store
----

TIP: You might have to run `gcloud auth configure-docker` for Jib to publish to your GCP container registry.

In the `k8s` directory, apply all the deployment descriptors to deploy all your images.

[source,shell]
----
bash kubectl-apply.sh -f
----

TIP: If you get an error about connecting to the server at `127.0.0.1:64317`, it's because you haven't <<create-cluster,created a cluster>> yet.

You can monitor the progress of your deployments with `kubectl get pods`. You'll likely see a number of pods have restarted several times. This is because there's no Keycloak instance deployed and it's trying to connect.

=== Configure Your Kubernetes Cluster for OIDC

First, I'm going to show you the _wrong_ way to configure your deployments to work with Okta. I'm showing you this way because it's fast and it's fun to see things running. Why is it wrong? Because you're storing secrets in files that might be checked into source control.

Edit `k8s/registry-k8s/jhipster-registry.yml` and add your OIDC settings to the `env` key. You should be able to get these values from `gateway/.okta.env`.

[source,yaml]
----
- name: SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_OIDC_ISSUER_URI
  value: "https://{yourOktaDomain}/oauth2/default"
- name: SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_OIDC_CLIENT_ID
  value: "{yourClientId}"
- name: SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_OIDC_CLIENT_SECRET
  value: "{yourClientSecret}"
----

Add these same values to the `*-deployment.yml` files in `blog-k8s`, `gateway-k8s`, and `store-k8s`. Run `./kubectl-apply.sh -f` again.

Once everything is up and running, get the external IP of your gateway.

[source,shell]
----
kubectl get svc gateway
----

You'll need to add the external IP address as a valid redirect to your Okta OIDC app. Run `okta login`, open the returned URL in your browser, and sign in to the Okta Admin Console. Go to the **Applications** section, find your application, and edit it. Duplicate the existing `localhost` URLs, replacing `localhost` with the IP address. For example, `http://34.71.48.244:8080/login/oauth2/code/oidc` for the login redirect URI and `http://34.71.48.244:8080` for the logout redirect URI.

You can use the following command to set your gateway's IP address as a variable you can curl.

[source,shell]
----
EXTERNAL_IP=$(kubectl get svc gateway -ojsonpath="{.status.loadBalancer.ingress[0].ip}")
curl $EXTERNAL_IP:8080
----

Open `\http://$EXTERNAL_IP:8080` in a browser, and you should be able to sign in.

image::{% asset_path 'blog/reactive-java-kubernetes/gke-first-login.png' %}[alt=First log in on GKE,width=652,align=center]

Great! Now you know things work, let's integrate better security, starting with HTTPS.

=== Add HTTPS

You should always use HTTPS. It's one of the easiest ways to secure things, especially free certificates these days.

You'll need an external IP you can assign TLS (the official name for HTTPS) certificate too.

[source,shell]
----
gcloud compute addresses create gateway-ingress-ip --global
----

You can run the following command to make sure it worked.

[source,shell]
----
gcloud compute addresses describe gateway-ingress-ip --global \
  --format='value(address)'
----

Then, create a `k8s/ingress.yml` file:

[source,yaml]
----
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: gateway
  annotations:
    kubernetes.io/ingress.global-static-ip-name: "gateway-ingress-ip"
spec:
  rules:
  - http:
      paths:
      - path: /*
        backend:
          serviceName: gateway
          servicePort: 8080
----

Deploy it and make sure it worked.

[source,shell]
----
kubectl get ingress gateway
----

Set the IP in a variable, as well as the domain.

[source,shell]
----
EXTERNAL_IP=$(kubectl get ingress gateway -ojsonpath="{.status.loadBalancer.ingress[0].ip}")
DOMAIN="${EXTERNAL_IP}.xip.io"
curl $DOMAIN

echo $DOMAIN
----

To create a certificate, create a `k8s/certificate.yml` file. Make sure to replace the `${DOMAIN}` with your domain. YAML isn't that smart!

[source,shell]
----
cat << EOF > certificate.yml
apiVersion: networking.gke.io/v1beta2
kind: ManagedCertificate
metadata:
  name: gateway-certificate
spec:
  domains:
  # Replace the value with your domain name
  - ${DOMAIN}
EOF
----

Add certificate to ingress.yml

[source,yaml]
----
# need before YAML
networking.gke.io/managed-certificates: "gateway-certificate"
----

Deploy both files:

[source,shell]
----
kubectl apply -f certificate.yml
kubectl apply -f ingress.yml
----

Check status:

[source,shell]
----
kubectl describe managedcertificate gateway-certificate
----

=== Force HTTPS

https://twitter.com/mraible/status/1372964940491993088

[source,java]
----
http.redirectToHttps(redirect -> redirect
    .httpsRedirectWhen(e -> e.getRequest().getHeaders().containsKey("X-Forwarded-Proto"))
    );
----

kubectl patch gateway-k8s/gateway-deployment.yml -p "{\"spec\": {\"template\": {\"metadata\": { \"labels\": {  \"redeploy\": \"$(date +%s)\"}}}}}"

// Restart

kubectl get deployments

kubectl rollout restart deployment gateway

kubectl logs gateway-db46684b5-9w22q --tail=-1

34.95.101.174.xip.io



https://cloud.google.com/load-balancing/docs/https/setting-up-http-https-redirect#partial-http-lb

gcloud compute forwarding-rules create http-content-rule \
--address=34.95.101.174 \
--global \
--target-http-proxy=http-lb-proxy \
--ports=80

Use `kubectl get svc` to get IP

kubectl scale deployments/gateway --replicas=0


gcloud container clusters delete jhipster --zone=us-central1-a


So much more! Secrets, encryption, oh my.

== Keeping Kubernetes Secrets

Describe most, show one. Talk to Ray.

=== Current State of Secret Management
https://twitter.com/daniel_bilar/status/1379845799086022661?s=21

=== JHipster Registry Encryption

=== Google Cloud Secret Manager

https://spring-gcp.saturnism.me/app-dev/cloud-services/secret-management

=== Sealed Secrets

https://github.com/bitnami-labs/sealed-secrets/blob/main/docs/GKE.md

=== Spring Vault


- https://developer.okta.com/blog/2020/05/04/spring-vault

=== Volume Mounted Secrets (configtree)

=== Git with Kubeseal

https://dev.to/stack-labs/store-your-kubernetes-secrets-in-git-thanks-to-kubeseal-hello-sealedsecret-2i6h

== Continuous Integration and Delivery

== K9s

== Learn More About Java Microservices and Kubernetes

[source,shell]
----
git clone https://github.com/oktadeveloper/java-microservices-examples.git
cd java-microservices-examples/reactive-jhipster
----

TIP: If you just want to see the completed project, just cd into the project's `jhipster-k8s` directory.

[source,shell]
----
cd ../jhipster-k8s
----

posts:

- Reactive Java
- Micronaut
- Quarkus
- Jib
- How to Docker

https://www.jhipster.tech/kubernetes/
